  -------
  Main
  -------

  <<op4j 1.0-beta1 RELEASED!>> (March 3rd, 2010). {{{download.html}[DOWNLOAD]}}

  This software is in beta stage, although fairly stable and tested already. An official stable release is intended for Spring 2010.

Bending the Java spoon

  <<op4j>> (pronounced <"opah">) <<is a developer happiness tool>>. It is a Java library aimed at
  improving quality, cleanness and readibility of Java code, especially auxiliary code like
  structure iteration, mapping, data conversion...
  
  op4j allows you to create <<chained operation expressions>> which apply both predefined or user-defined
  functions to your objects in a fluid and readable way. This improves the way your code looks and 
  greatly reduces the complexity of executing auxiliary low-level tasks in the highly bureaucratic, statically 
  -and strongly- typed language that Java is.  

  op4j is open source, and it is distributed under the terms of the Apache License 2.0.
  
  Read the quick example below, go to <<{{{basics.html}The Basics Page}}>> or choose any link from the
  menu on the left.
  
* A very quick overview example

  op4j expressions usually start with <<Op.on(...)>> (read it as <"operate on">) specifying the object on 
  which op4j will operate, and end with <<get()>>, which returns the result of the 
  expression. Let's see an example:

  First, let's convert a <<<List\<String\>>>> into an (ordered) <<<Set\<String\>>>>:

---
  // Without op4j
  Set<String> set = new LinkedHashSet<String>(list);
      
  // With op4j
  Set<String> set = Op.on(list).toSet().get();
---

  Ok, this was a little bit more readable than "normal" java code... but what if all those 
  Strings where dates in the <<<dd/MM/yyyy>>> format and we wanted to 
  convert them to <<<java.util.Calendar>>> objects? 
  Let's iterate the newly created set and execute one of op4j's more than 100 predefined 
  functions on each of the array's elements...

---
  Set<Calendar> set = 
      Op.on(list).toSet().forEach().exec(FnString.toCalendar("dd/MM/yyyy")).get();
---

  That was cool. But unfortunately, some of those Strings can be null, and of course
  we don't want to apply the conversion on them, so let's add a check... 

---
  Set<Calendar> set = 
      Op.on(list).toSet().forEach().ifNotNull().exec(FnString.toCalendar("dd/MM/yyyy")).get();
---

  ...which is equivalent to:

---
  Set<Calendar> set = 
      Op.on(list).toSet().forEach().execIfNotNull(FnString.toCalendar("dd/MM/yyyy")).get();
---

  And a <<<forEach().exec()>>> (= <execute on each>) operation is what is usually called a "map" operation, so let's
  use that name (with the added nullity check): 

---
  Set<Calendar> set = 
      Op.on(list).toSet().mapIfNotNull(FnString.toCalendar("dd/MM/yyyy")).get();
---

  Wow! this looks great. There is no need to compare with "normal" java code, right?... but let's do it anyway ;-)

---
  // ****************************
  // WARNING: Non-op4j code!!
  // ****************************
  SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
  Set<Calendar> set = new LinkedHashSet<Calendar>();
  for (String element : list) {
    if (element != null) {
        Date date = dateFormat.parse(element);
        Calendar calendar = Calendar.getInstance();
        calendar.setTimeInMillis(date.getTime());
        aux.add(calendar);
    }
  }
---

  And... what if we didn't really want to execute this operation right there, but rather just define it
  and use it later? Well, then instead of our <<Op.on(...)>> we can create an equivalent 
  <<Fn.on(...)>> one with exactly the same structure, and we will obtain an executable 
  <<<Function\<List\<String\>,Set\<Calendar\>\>>>> object (read it as <"Function that receives
  a List of String and returns a Set of Calendar">) at the other end:
  
---
  Function<List<String>,Set<Calendar>> conversionFunction = 
      Fn.onListOf(Types.STRING).toSet().mapIfNotNull(FnString.toCalendar("dd/MM/yyyy")).get();
---

  ...and then we can execute it just like:
  
---
  Set<Calendar> set = conversionFunction.execute(list);
---
  
  ...or even use it in an <<<exec>>> expression exactly as any other predefined (or user-defined)
  function, like:  
  
---
  List<List<String>> listOfListOfStrings = ...
  List<Set<Calendar>> listOfSetOfCalendars =
      Op.on(listOfListOfStrings).forEach().exec(conversionFunction).get();
---
  
* Learning more...

  If you want to know more, here are some documentation links:
  
    * {{{basics.html}The Basics}}
    
    * {{{arrays.html}Working with arrays}}
    
    * {{{lists.html}Working with lists}}
    
    * {{{maps.html}Working with maps}}
    
    * {{{sets.html}Working with sets}}
    
    * {{{generic.html}Working with any object of any type (generic operations)}}

  
  

