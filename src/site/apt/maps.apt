  -------
  Working with maps
  -------

Working with maps

  This page explains how op4j can deal with map objects (objects 
  implementing <<<java.util.Map\<K,V\>>>>).

  Map input objects are considered immutable, so they will not be changed when used in an op4j
  expression and a new map will always be returned when executing <<<get()>>>.
  
  This, however, does not apply to the input map element objects, which could be changed if you
  executed on them any functions which might change their state instead of substituting them 
  for new elements.

* Creating map expressions

** Operation expressions

  There are two equivalent ways of creating an operation expression on a map. Just use the method
  you like most:
  
---
Map<String,String> map = ...;
Op.on(map)...
---
  
---
Map<String,String> map = ...;
Op.onMap(map)...
---



** Function expressions

  Function expressions are created as usual with other structures:
  
---
// Create a function which receives a Map<Integer,String> variable as input
function = Fn.onMapOf(Types.INTEGER, Types.STRING)...get();
---
     
     
* Building maps

  Maps can be built from their elements in a number of different ways by creating a generic 
  operator (which can be <unique> or <multiple>) and then calling one of the <buildMap> actions.
  
  Not only maps (<<<Map\<K,V\>>>>) can be built this way, but also maps of arrays
  (<<<Map\<K,V[]\>>>>), maps of lists (<<<Map\<K,List\<V\>\>>>>) and maps of sets
  (<<<Map\<K,Set\<V\>\>>>>), which are the result of grouping multiple values with the same 
  assigned key. 
  
  
** Building Map\<K,V\> objects 

*** Using a Map Builder
  
---
IMapBuilder<String,Integer,String> mapBuilder = ...;
Map<Integer,String> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMap(mapBuilder).get();
---


*** Evaluating keys
  
---
IFunction<String,Integer> keyEval = ...;
Map<Integer,String> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMapByKeyEval(keyEval).get();
---


*** Alternating elements
  
---
Map<String,String> capitalsByTerritory = 
    Op.onAll("Galicia", "Santiago", "Spain", "Madrid", "EU", "Brussels").
        buildMapByAlternateElements().get();
---



** Building Map\<K,V[]\> objects
  
  Maps of arrays are created in the same way as <<<Map\<K,V\>>>>, but elements with
  the same key are now grouped into arrays instead of all but the last one being discarded.

  Building maps of arrays needs the type of the arrays' elements in order to being able to 
  instantiate those arrays. 

*** Using a Map Builder
  
---
IMapBuilder<String,Integer,String> mapBuilder = ...;
Map<Integer,String[]> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMapOfArrayOf(Types.STRING, mapBuilder).get();
---

*** Evaluating keys
  
---
IFunction<String,Integer> keyEval = ...;
Map<Integer,String[]> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMapOfArrayByKeyEvalOf(Types.STRING, keyEval).get();
---

*** Alternating elements
  
---
Map<String,String[]> citiesByCountry = 
    Op.onAll("Spain", "Santiago", "Spain", "Madrid", "Belgium", "Brussels").
        buildMapOfArrayByAlternateElementsOf(Types.STRING).get();
---


** Building Map\<K,List\<V\>\> objects 
  
  Maps of lists are created in the same way as <<<Map\<K,V\>>>>, but elements with
  the same key are now grouped into lists instead of all but the last one being discarded.

*** Using a Map Builder
  
---
IMapBuilder<String,Integer,String> mapBuilder = ...;
Map<Integer,List<String>> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMapOfList(mapBuilder).get();
---

*** Evaluating keys
  
---
IFunction<String,Integer> keyEval = ...;
Map<Integer,List<String>> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMapOfListByKeyEval(keyEval).get();
---

*** Alternating elements
  
---
Map<String,List<String>> citiesByCountry = 
    Op.onAll("Spain", "Santiago", "Spain", "Madrid", "Belgium", "Brussels").
        buildMapOfListByAlternateElements().get();
---


** Building Map\<K,Set\<V\>\> objects 
  
  Maps of sets are created in the same way as <<<Map\<K,V\>>>>, but elements with
  the same key are now grouped into sets instead of all but the last one being discarded.

*** Using a Map Builder
  
---
IMapBuilder<String,Integer,String> mapBuilder = ...;
Map<Integer,Set<String>> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMapOfSet(mapBuilder).get();
---

*** Evaluating keys
  
---
IFunction<String,Integer> keyEval = ...;
Map<Integer,Set<String>> map = 
    Op.onAll("Santiago", "Madrid", "Brussels").buildMapOfSetByKeyEval(keyEval).get();
---

*** Alternating elements
  
---
Map<String,Set<String>> citiesByCountry = 
    Op.onAll("Spain", "Santiago", "Spain", "Madrid", "Belgium", "Brussels").
        buildMapOfSetByAlternateElements().get();
---



* Extracting keys and values
  
  All keys of a map can be extracted as a Set:

---
Map<Integer,String> map = 
Set<Integer> keys = Op.on(map).extractKeys().get();
---

  Also values can be extracted, as a List:

---
Map<Integer,String> map = 
List<String> values = Op.on(map).extractValues().get();
---
  
  

* Iterating

  Maps can be iterated, resulting in an operator acting on its <map entries> (<<<Map.Entry\<K,V\>>>>).

---
Op.on(map).forEachEntry()...
---

  And once iterating each entry, actions can be executed on the entry itself (having thus access
  to both key and value):

---
Op.on(map).forEachEntry().[ACTIONS ON MAP ENTRIES]...
---
  
  But also the keys can be selected, so that subsequent actions will only apply on the map's keys:

---
Op.on(map).forEachEntry().onKey().[ACTIONS ON MAP KEYS]...
---

  ...and the same for the values:

---
Op.on(map).forEachEntry().onValue().[ACTIONS ON MAP VALUES]...
---
    
  The result obtained when executing <<<get()>>> after iterating will be a map with the results 
  of applying the subsequently chained actions on the entries/keys/values of the map.  

  Iteration on entries can be ended with the <<<endFor()>>> action:

---
Op.on(map).forEachEntry().[ENTRY ACTIONS].endFor().[MAP ACTIONS].get();
---

  And selection of keys or values can be ended with the <<<endOn()>>> action:

---
Op.on(map).forEachEntry().onKey().[KEY ACTIONS].endOn().endFor().[MAP ACTIONS].get();
Op.on(map).forEachEntry().onValue().[VALUE ACTIONS].endOn().endFor().[MAP ACTIONS].get();
---
   
  
* Modifying

  A map can be modified by adding or removing elements from it. 
  
  Maps in op4j are ordered (<<<LinkedHashMap>>>), and several options for adding new 
  elements at the end of a map:

---
Map<String,String> map = ...;
Map<String,String> newElements = ...;
...
Op.on(map).put("new Key", "new Value")...
Op.on(map).putAll(newElements)...
---

  New elements can also be inserted into a specific position. Positions start with 0.

---
Map<String,String> map = ...;
Map<String,String> newElements = ...;
...
Op.on(map).insert(0, "new Key", "new Value")...
Op.on(map).insertAll(0, newElements)...
---
  
  Removal of elements can be done in several ways. Elements can be removed attending to 
  their keys:

---
Op.on(map).removeAllKeys("one Key", "another Key")...
Op.on(map).removeAllKeysNot("one Key", "another Key")...
---

  A function returning <<<Boolean>>> can be used as evaluator to determine whether
  an element should be removed or not:
  
---
Map<String,String> map = ...;
IFunction<Map.Entry<String,String>,Boolean> eval = ...;
...
Op.on(map).removeAllTrue(eval)...
Op.on(map).removeAllFalse(eval)...
---




* Executing functions
  
** Executing functions on the map keys or values

  Functions can be executed on each of the map keys or values after a 
  <forEachEntry()> followed by and an <onKey()> or <onValue()> action:

---
Map<String,String> map = ...;
...
Map<String,String> newMap = 
    Op.on(map).forEachEntry().onValue().exec(FnString.toUpperCase()).get();
---

  A condition can be added for <null-saving> a function execution, if needed:

---
Map<String,String> map = ...;
IFunction<String,String> myFunction = ...;
...
Map<String,String> newMap = 
    Op.on(map).forEachEntry().onValue().execIfNotNull(myFunction).get();
---


  
** Executing functions on map entries

  Functions can be executed on entire map entries. 
  
  These functions can return <<<Map.Entry\<K,V\>>>> objects as well, in which case the target
  object will be still considered a map:

---
Map<String,String> map = ...;
IFunction<Map.Entry<String,String>,Map.Entry<String,String>> myFunction = ...;
...
Map<String,String> newMap = 
    Op.on(map).forEachEntry().execAsMapEntry(myFunction).get();
---

  ...or they can return something different from a map entry, in which case the target object
  will be considered a List from then on:

---
Map<String,String> map = ...;
IFunction<Map.Entry<String,String>,Integer> myFunction = ...;
...
List<Integer> newList = 
    Op.on(map).forEachEntry().exec(myFunction).get();
---

  
** Executing functions on the whole map

  If a map has not been iterated (<forEach()>) (or it has, but <endFor()> has been called), functions
  can be executed on the whole map. 

  There are three ways of executing functions on a map as a whole:
  
    * Executions which return a map (example: Map\<String,String\> -> Map\<String,Integer\>)
    
    * Executions which do not return a map (example: Map\<String,String\> -> Calendar)
    
    
*** Returning a map

  Functions will be executed using the <<<execAsMap(...)>>> action:

---
Map<String,String> map = ...;
IFunction<Map<String,String>,Map<String,Integer>> myFunction = ...;
...
Op.on(map).execAsMap(myFunction)...
---

  A not-null check can be added:  

---
Map<String,String> map = ...;
IFunction<Map<String,String>,Map<String,Integer>> myFunction = ...;
...
Op.on(map).execIfNotNullAsMap(myFunction)...
---
    
    
*** Not returning a map

---
Map<String,String> map = ...;
IFunction<Map<String,String>,Calendar> myFunction = ...;
...
Calendar calendar = Op.on(map).exec(myFunction).get();
---






  
  
* Selecting (conditional code)

  op4j allows the conditional execution of actions. Once the condition (an action starting with
  "<<<if>>>") is executed, all subsequent actions will apply only on the selected parts of the target object.
  
  For example, lets convert into upper case only the first String key of the map:
  
---
Map<String,String> map = ...;
Map<String> newMap = Op.on(map).forEachEntry().ifIndex(0).onKey().exec(FnString.toUpperCase()).get();
---

  Selections can be ended with <<<endIf(...)>>>:
  
---
Map<String> newMap =  
    Op.on(map).forEachEntry().ifIndex(0,1,3).[ACTIONS ON SELECTED ENTRIES].endIf()...
---



** Selecting specific map keys/values  

  If a selection is executed after <forEachEntry().onKey()> or <forEachEntry().onValue()>, it will 
  be applied on the map keys or values, respectively.
  
  Selection can be based on the nullity of the element:  

---  
Op.on(map).forEachEntry().onValue().ifNull()....
Op.on(map).forEachEntry().onValue().ifNotNull()....
---

  And also on the value returned by the evaluation of a function returning <<<Boolean>>>:
  
---
Map<String,String> map = ...;
IFunction<String,Boolean> eval = ...;
...
Op.on(map).forEachEntry().onValue().ifTrue(eval)...
Op.on(map).forEachEntry().onValue().ifFalse(eval)...
Op.on(map).forEachEntry().onValue().ifNullOrTrue(eval)...
Op.on(map).forEachEntry().onValue().ifNullOrFalse(eval)...
Op.on(map).forEachEntry().onValue().ifNotNullAndTrue(eval)...
Op.on(map).forEachEntry().onValue().ifNotNullAndFalse(eval)...
---
  
  

** Selecting specific map entries  

  If a selection is executed after a <forEachEntry()> action without <onKey()> or <onValue()> being
  executed, it will be applied on the map entries.
  
  Selection can be done on the entry's position in the map:

---  
Op.on(map).forEachEntry().ifIndex(0,2,3)....
Op.on(map).forEachEntry().ifIndexNot(0,1,5)....
---
  
  ...on the value of its key:

---  
Op.on(map).forEachEntry().ifKeyEquals("a key", "another key")....
Op.on(map).forEachEntry().ifKeyNotEquals("a key", "another key")....
---

  ...and also on the value returned by the evaluation of a function returning <<<Boolean>>>:
  
---
Map<String,String> map = ...;
IFunction<Map.Entry<String,String>,Boolean> eval = ...;
...
Op.on(map).forEachEntry().ifTrue(eval)...
Op.on(map).forEachEntry().ifFalse(eval)...
---



** Selecting the map as a whole  

  Selection can also be performed on the map itself as a whole, effectively deciding whether
  subsequent actions will be executed at all or not. 

---  
Map<String,String> map = ...;
IFunction<Map<String,String>,Boolean> eval = ...;
...
Op.on(map).ifNull()....
Op.on(map).ifNotNull()....
Op.on(map).ifTrue(eval)...
Op.on(map).ifFalse(eval)...
Op.on(map).ifNullOrTrue(eval)...
Op.on(map).ifNullOrFalse(eval)...
Op.on(map).ifNotNullAndTrue(eval)...
Op.on(map).ifNotNullAndFalse(eval)...
---


** Restricions on execution actions after selection

  After executing a selection action, function executed by means of an <exec> action
  cannot change the map key and/or value types (i.e., a <<<Map\<String,String\>>>> must remain <<<Map\<String,String\>>>>.
  
  So this would not be valid:

---
// Will not compile!
Map<String,String> newMap = 
    Op.on(map).forEachEntry().ifIndex(0,1,3).onKey().exec(FnString.toInteger()).get();
---

  ...because converting only <some> of the map keys to integer would render the map type
  inconsistent (some elements would be <<<String>>>, some other <<<Integer>>>).

  This is perfectly valid, though:

---
// FnString.toUpperCase is IFunction<String,String>
Map<String,String> newMap = 
    Op.on(map).forEachEntry().ifIndex(0,1,3).onKey().exec(FnString.toUpperCase()).get();
---
  

* Replacing

  Map keys, values, entries or even the map itself can be replaced by other objects:
  
---
Map<String,String> newMap = 
    Op.on(map).forEachEntry().onValue().ifNull().replaceWith("[no value]").get();
---

  ...which is equivalent to:
  
---
Map<String,String> newMap = 
    Op.on(map).forEachEntry().onValue().replaceIfNullWith("[no value]").get();
---
  

